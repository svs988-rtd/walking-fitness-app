{"ast":null,"code":"export class ProgressionAlgorithm {\n  // 80% completion rate\n\n  static getRecommendation(sessions) {\n    if (sessions.length === 0) {\n      return {\n        recommendedDuration: this.MIN_DURATION,\n        reason: \"Starting with a gentle 3-minute walk\",\n        confidenceLevel: 'high'\n      };\n    }\n    const recentSessions = this.getRecentSessions(sessions, 7); // Last 7 days\n    const lastSession = sessions[sessions.length - 1];\n    if (recentSessions.length < this.MIN_SESSIONS_FOR_PROGRESSION) {\n      return {\n        recommendedDuration: lastSession.duration,\n        reason: \"Continue with current duration to build consistency\",\n        confidenceLevel: 'medium'\n      };\n    }\n    const completionRate = this.calculateCompletionRate(recentSessions);\n    const consistency = this.calculateConsistency(recentSessions);\n    const currentDuration = this.getMostCommonDuration(recentSessions);\n    if (completionRate >= this.COMPLETION_THRESHOLD && consistency >= 0.7) {\n      const newDuration = Math.min(Math.round(currentDuration * (1 + this.PROGRESSION_RATE)), this.MAX_DURATION);\n      if (newDuration > currentDuration) {\n        return {\n          recommendedDuration: newDuration,\n          reason: `Great progress! Ready for ${this.formatDuration(newDuration)}`,\n          confidenceLevel: 'high'\n        };\n      }\n    }\n    if (completionRate < 0.5) {\n      const newDuration = Math.max(Math.round(currentDuration * 0.9), this.MIN_DURATION);\n      return {\n        recommendedDuration: newDuration,\n        reason: \"Let's try a shorter duration to build confidence\",\n        confidenceLevel: 'medium'\n      };\n    }\n    return {\n      recommendedDuration: currentDuration,\n      reason: \"Keep building consistency at this level\",\n      confidenceLevel: 'medium'\n    };\n  }\n  static getRecentSessions(sessions, days) {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - days);\n    return sessions.filter(session => new Date(session.date) >= cutoffDate);\n  }\n  static calculateCompletionRate(sessions) {\n    if (sessions.length === 0) return 0;\n    const completed = sessions.filter(s => s.completed).length;\n    return completed / sessions.length;\n  }\n  static calculateConsistency(sessions) {\n    if (sessions.length === 0) return 0;\n\n    // Calculate how many of the last 7 days had walking sessions\n    const dates = sessions.map(s => new Date(s.date).toDateString());\n    const uniqueDates = new Set(dates);\n    return uniqueDates.size / 7; // Consistency over 7 days\n  }\n  static getMostCommonDuration(sessions) {\n    if (sessions.length === 0) return this.MIN_DURATION;\n    const durations = sessions.map(s => s.duration);\n    const frequency = {};\n    durations.forEach(duration => {\n      frequency[duration] = (frequency[duration] || 0) + 1;\n    });\n    return Number(Object.keys(frequency).reduce((a, b) => frequency[Number(a)] > frequency[Number(b)] ? a : b));\n  }\n  static formatDuration(seconds) {\n    const minutes = Math.floor(seconds / 60);\n    return `${minutes} minute${minutes !== 1 ? 's' : ''}`;\n  }\n  static getProgressStats(sessions) {\n    const completed = sessions.filter(s => s.completed);\n    const totalTime = completed.reduce((sum, s) => sum + s.duration, 0);\n    return {\n      totalSessions: sessions.length,\n      completedSessions: completed.length,\n      totalWalkingTime: totalTime,\n      currentStreak: this.calculateCurrentStreak(sessions),\n      averageDuration: completed.length > 0 ? Math.round(totalTime / completed.length) : 0\n    };\n  }\n  static calculateCurrentStreak(sessions) {\n    if (sessions.length === 0) return 0;\n    const sortedSessions = sessions.filter(s => s.completed).sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());\n    let streak = 0;\n    let currentDate = new Date();\n    currentDate.setHours(0, 0, 0, 0);\n    for (const session of sortedSessions) {\n      const sessionDate = new Date(session.date);\n      sessionDate.setHours(0, 0, 0, 0);\n      const daysDiff = Math.floor((currentDate.getTime() - sessionDate.getTime()) / (1000 * 60 * 60 * 24));\n      if (daysDiff === streak) {\n        streak++;\n      } else if (daysDiff === streak + 1) {\n        // Allow for missing yesterday if we're checking today\n        streak++;\n      } else {\n        break;\n      }\n      currentDate = sessionDate;\n    }\n    return streak;\n  }\n}\nProgressionAlgorithm.MIN_DURATION = 180;\n// 3 minutes\nProgressionAlgorithm.MAX_DURATION = 1800;\n// 30 minutes\nProgressionAlgorithm.PROGRESSION_RATE = 0.1;\n// 10% increase\nProgressionAlgorithm.MIN_SESSIONS_FOR_PROGRESSION = 3;\nProgressionAlgorithm.COMPLETION_THRESHOLD = 0.8;","map":{"version":3,"names":["ProgressionAlgorithm","getRecommendation","sessions","length","recommendedDuration","MIN_DURATION","reason","confidenceLevel","recentSessions","getRecentSessions","lastSession","MIN_SESSIONS_FOR_PROGRESSION","duration","completionRate","calculateCompletionRate","consistency","calculateConsistency","currentDuration","getMostCommonDuration","COMPLETION_THRESHOLD","newDuration","Math","min","round","PROGRESSION_RATE","MAX_DURATION","formatDuration","max","days","cutoffDate","Date","setDate","getDate","filter","session","date","completed","s","dates","map","toDateString","uniqueDates","Set","size","durations","frequency","forEach","Number","Object","keys","reduce","a","b","seconds","minutes","floor","getProgressStats","totalTime","sum","totalSessions","completedSessions","totalWalkingTime","currentStreak","calculateCurrentStreak","averageDuration","sortedSessions","sort","getTime","streak","currentDate","setHours","sessionDate","daysDiff"],"sources":["/Users/stevegreen/code/walking-fitness-app/src/utils/progressionAlgorithm.ts"],"sourcesContent":["interface WalkingSession {\n  date: string;\n  duration: number;\n  completed: boolean;\n}\n\ninterface ProgressionRecommendation {\n  recommendedDuration: number;\n  reason: string;\n  confidenceLevel: 'low' | 'medium' | 'high';\n}\n\nexport class ProgressionAlgorithm {\n  private static readonly MIN_DURATION = 180; // 3 minutes\n  private static readonly MAX_DURATION = 1800; // 30 minutes\n  private static readonly PROGRESSION_RATE = 0.1; // 10% increase\n  private static readonly MIN_SESSIONS_FOR_PROGRESSION = 3;\n  private static readonly COMPLETION_THRESHOLD = 0.8; // 80% completion rate\n\n  static getRecommendation(sessions: WalkingSession[]): ProgressionRecommendation {\n    if (sessions.length === 0) {\n      return {\n        recommendedDuration: this.MIN_DURATION,\n        reason: \"Starting with a gentle 3-minute walk\",\n        confidenceLevel: 'high'\n      };\n    }\n\n    const recentSessions = this.getRecentSessions(sessions, 7); // Last 7 days\n    const lastSession = sessions[sessions.length - 1];\n    \n    if (recentSessions.length < this.MIN_SESSIONS_FOR_PROGRESSION) {\n      return {\n        recommendedDuration: lastSession.duration,\n        reason: \"Continue with current duration to build consistency\",\n        confidenceLevel: 'medium'\n      };\n    }\n\n    const completionRate = this.calculateCompletionRate(recentSessions);\n    const consistency = this.calculateConsistency(recentSessions);\n    const currentDuration = this.getMostCommonDuration(recentSessions);\n\n    if (completionRate >= this.COMPLETION_THRESHOLD && consistency >= 0.7) {\n      const newDuration = Math.min(\n        Math.round(currentDuration * (1 + this.PROGRESSION_RATE)),\n        this.MAX_DURATION\n      );\n      \n      if (newDuration > currentDuration) {\n        return {\n          recommendedDuration: newDuration,\n          reason: `Great progress! Ready for ${this.formatDuration(newDuration)}`,\n          confidenceLevel: 'high'\n        };\n      }\n    }\n\n    if (completionRate < 0.5) {\n      const newDuration = Math.max(\n        Math.round(currentDuration * 0.9),\n        this.MIN_DURATION\n      );\n      \n      return {\n        recommendedDuration: newDuration,\n        reason: \"Let's try a shorter duration to build confidence\",\n        confidenceLevel: 'medium'\n      };\n    }\n\n    return {\n      recommendedDuration: currentDuration,\n      reason: \"Keep building consistency at this level\",\n      confidenceLevel: 'medium'\n    };\n  }\n\n  private static getRecentSessions(sessions: WalkingSession[], days: number): WalkingSession[] {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - days);\n    \n    return sessions.filter(session => new Date(session.date) >= cutoffDate);\n  }\n\n  private static calculateCompletionRate(sessions: WalkingSession[]): number {\n    if (sessions.length === 0) return 0;\n    const completed = sessions.filter(s => s.completed).length;\n    return completed / sessions.length;\n  }\n\n  private static calculateConsistency(sessions: WalkingSession[]): number {\n    if (sessions.length === 0) return 0;\n    \n    // Calculate how many of the last 7 days had walking sessions\n    const dates = sessions.map(s => new Date(s.date).toDateString());\n    const uniqueDates = new Set(dates);\n    \n    return uniqueDates.size / 7; // Consistency over 7 days\n  }\n\n  private static getMostCommonDuration(sessions: WalkingSession[]): number {\n    if (sessions.length === 0) return this.MIN_DURATION;\n    \n    const durations = sessions.map(s => s.duration);\n    const frequency: { [key: number]: number } = {};\n    \n    durations.forEach(duration => {\n      frequency[duration] = (frequency[duration] || 0) + 1;\n    });\n    \n    return Number(Object.keys(frequency).reduce((a, b) => \n      frequency[Number(a)] > frequency[Number(b)] ? a : b\n    ));\n  }\n\n  private static formatDuration(seconds: number): string {\n    const minutes = Math.floor(seconds / 60);\n    return `${minutes} minute${minutes !== 1 ? 's' : ''}`;\n  }\n\n  static getProgressStats(sessions: WalkingSession[]): {\n    totalSessions: number;\n    completedSessions: number;\n    totalWalkingTime: number;\n    currentStreak: number;\n    averageDuration: number;\n  } {\n    const completed = sessions.filter(s => s.completed);\n    const totalTime = completed.reduce((sum, s) => sum + s.duration, 0);\n    \n    return {\n      totalSessions: sessions.length,\n      completedSessions: completed.length,\n      totalWalkingTime: totalTime,\n      currentStreak: this.calculateCurrentStreak(sessions),\n      averageDuration: completed.length > 0 ? Math.round(totalTime / completed.length) : 0\n    };\n  }\n\n  private static calculateCurrentStreak(sessions: WalkingSession[]): number {\n    if (sessions.length === 0) return 0;\n    \n    const sortedSessions = sessions\n      .filter(s => s.completed)\n      .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());\n    \n    let streak = 0;\n    let currentDate = new Date();\n    currentDate.setHours(0, 0, 0, 0);\n    \n    for (const session of sortedSessions) {\n      const sessionDate = new Date(session.date);\n      sessionDate.setHours(0, 0, 0, 0);\n      \n      const daysDiff = Math.floor((currentDate.getTime() - sessionDate.getTime()) / (1000 * 60 * 60 * 24));\n      \n      if (daysDiff === streak) {\n        streak++;\n      } else if (daysDiff === streak + 1) {\n        // Allow for missing yesterday if we're checking today\n        streak++;\n      } else {\n        break;\n      }\n      \n      currentDate = sessionDate;\n    }\n    \n    return streak;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}